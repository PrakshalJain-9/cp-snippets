{
	"Modular Arithmetic and Prime Utilities": {
		"prefix": "numTheory",
		"body": [
			"// clang-format off",
			"int mod_mul(int a, int b, int mod = MOD) { return ((a % mod) * (b % mod)) % mod; }",
			"int mod_exponentiation(int base, int power, int mod) { int ans = 1; while (power) { if (power % 2) { ans = mod_mul(ans, base, mod); power--; } else { base = mod_mul(base, base, mod); power /= 2; } } return ans; }",
			"int mod_inverse(int a, int mod = MOD) { return mod_exponentiation(a, mod - 2, mod); }",
			"bool isPrime(int n) { if (n <= 1) return false; if (n <= 3) return true; if (n % 2 == 0 || n % 3 == 0) return false; for (int i = 5; i * i <= n; i += 6) { if (n % i == 0 || n % (i + 2) == 0) return false; } return true; }",
			"int prob(int a,int b,int mod = 1000000007){ return mod_mul(a, mod_inverse(b, mod), mod);}",
			"vector<int> spfarr(int n){int maxi = n;vector<int> spf(maxi, 0); for (int i = 2; i <= maxi; i++) {if (spf[i] != 0) continue; spf[i] = i; for (int j = i * i; j <= maxi; j += i){ if (spf[j] == 0) spf[j] = i;}}return spf;}",
			"int mod_division(int a, int b, int mod = MOD) { return mod_mul(a, mod_inverse(b, mod), mod); }",
			"// clang-format on",
			"",
			"",
			"$2"
		],
		"description": "Compact modular arithmetic and prime utilities for C++"
	}
}